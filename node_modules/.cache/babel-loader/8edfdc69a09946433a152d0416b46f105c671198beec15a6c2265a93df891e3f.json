{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useExcelParser.js\nimport { useState, useCallback } from 'react';\nimport { GREY_FILLS, HEADER_PATTERNS } from '../utils/constants';\nimport { fieldDefinitions } from '../utils/fieldDefinitions'; // Using the same fieldDefinitions\n\nexport function useExcelParser() {\n  _s();\n  const [parsingError, setParsingError] = useState(null);\n  const [isParsing, setIsParsing] = useState(false);\n  const findWorksheet = useCallback(workbook => {\n    const sheet = workbook.worksheets.find(ws => {\n      const headerRow = ws.getRow(1).values; // .values can include empty slots\n      if (!Array.isArray(headerRow)) return false;\n      return headerRow.some(cellValue => typeof cellValue === 'string' && HEADER_PATTERNS.some(pattern => cellValue.toLowerCase().includes(pattern.toLowerCase())));\n    });\n    return sheet || workbook.worksheets[0]; // Fallback to the first sheet\n  }, []);\n  const detectPeriodsInHeader = useCallback(worksheet => {\n    const headerRowValues = worksheet.getRow(1).values || [];\n    let detectedPeriods = 0;\n    headerRowValues.forEach(cellValue => {\n      if (typeof cellValue === 'string' && cellValue.toLowerCase().startsWith('período ')) {\n        detectedPeriods++;\n      }\n    });\n    // Fallback if \"Período X\" not found, try to infer from number of columns\n    // Assumes structure: Key, Description, P1, P2, ..., Note\n    if (detectedPeriods === 0 && Array.isArray(headerRowValues) && headerRowValues.length >= 3) {\n      // Count columns that are not \"Item (Chave Interna)\", \"Descrição (Português)\", or \"Nota\"\n      const potentialPeriodHeaders = headerRowValues.slice(2, -1); // Exclude first two and last one\n      detectedPeriods = potentialPeriodHeaders.length;\n    }\n    if (detectedPeriods === 0) return 2; // Default to 2 if no period columns detected\n    return Math.min(Math.max(detectedPeriods, 1), 6); // Clamp between 1 and 6\n  }, []);\n  const isConsideredGreyCell = useCallback(cell => {\n    if (!cell || !cell.fill) return true; // If no fill, treat as inputtable for flexibility\n    if (cell.fill.type === 'pattern' && cell.fill.pattern === 'solid' && cell.fill.fgColor && cell.fill.fgColor.argb) {\n      const fillColor = cell.fill.fgColor.argb.toUpperCase();\n      return GREY_FILLS.some(grey => fillColor === grey || fillColor.endsWith(grey)); // Check with and without FF prefix\n    }\n    return false; // If other fill type or pattern, not considered grey for input\n  }, []);\n  const parseFile = useCallback(async (file, ExcelJS) => {\n    setIsParsing(true);\n    setParsingError(null);\n    if (!ExcelJS) {\n      const err = new Error(\"Biblioteca ExcelJS não está carregada.\");\n      setParsingError(err);\n      setIsParsing(false);\n      throw err;\n    }\n    try {\n      const wb = new ExcelJS.Workbook();\n      await wb.xlsx.load(await file.arrayBuffer());\n      const ws = findWorksheet(wb);\n      if (!ws) {\n        throw new Error(\"Nenhuma planilha válida encontrada no arquivo Excel. Verifique se a primeira planilha contém os dados ou se o cabeçalho corresponde aos padrões esperados.\");\n      }\n      const detectedNumPeriods = detectPeriodsInHeader(ws);\n      const extractedDataForPeriods = Array(detectedNumPeriods).fill(null).map(() => ({}));\n      const allFieldKeys = Object.keys(fieldDefinitions);\n      let foundAnyData = false;\n      ws.eachRow((row, rowNumber) => {\n        var _row$getCell$value;\n        if (rowNumber === 1) return; // Skip header row\n\n        // Column A for field key (internal English key)\n        const fieldKeyFromFile = (_row$getCell$value = row.getCell(1).value) === null || _row$getCell$value === void 0 ? void 0 : _row$getCell$value.toString().trim();\n        if (!fieldKeyFromFile || !allFieldKeys.includes(fieldKeyFromFile)) {\n          // console.warn(`Linha ${rowNumber}: Chave de campo \"${fieldKeyFromFile}\" não reconhecida ou ausente na coluna A. Pulando linha.`);\n          return;\n        }\n        const fieldDef = fieldDefinitions[fieldKeyFromFile];\n        for (let periodIdx = 0; periodIdx < detectedNumPeriods; periodIdx++) {\n          const dataCell = row.getCell(3 + periodIdx); // Data starts at column C (ExcelJS is 1-indexed)\n\n          if (fieldDef.firstPeriodOnly && periodIdx > 0) {\n            extractedDataForPeriods[periodIdx][fieldKeyFromFile] = null;\n            continue;\n          }\n          if (dataCell.value === \"[Não Aplicável]\") {\n            extractedDataForPeriods[periodIdx][fieldKeyFromFile] = null;\n            continue;\n          }\n\n          // Process if it's a grey cell OR if it has a value (for flexibility if user removes formatting)\n          if (isConsideredGreyCell(dataCell) || dataCell.value !== null && typeof dataCell.value !== 'object') {\n            const cellValue = dataCell.value;\n            if (cellValue !== null && typeof cellValue !== 'object') {\n              // typeof object can be Date\n              let numValue = Number(cellValue);\n              if (isNaN(numValue) && typeof cellValue === 'object' && cellValue.result !== undefined) {\n                // Formula result\n                numValue = Number(cellValue.result);\n              }\n              if (!isNaN(numValue)) {\n                extractedDataForPeriods[periodIdx][fieldKeyFromFile] = numValue;\n                foundAnyData = true;\n              } else {\n                extractedDataForPeriods[periodIdx][fieldKeyFromFile] = null;\n              }\n            } else {\n              extractedDataForPeriods[periodIdx][fieldKeyFromFile] = null;\n            }\n          } else {\n            extractedDataForPeriods[periodIdx][fieldKeyFromFile] = null; // Not a grey cell / no value\n          }\n        }\n      });\n      if (!foundAnyData) {\n        console.warn(\"Nenhum dado numérico encontrado nas células de entrada esperadas do Excel.\");\n        // Optionally throw an error or return empty if this is critical\n      }\n\n      // Ensure all defined fields are present in each period object, even if null\n      const finalData = extractedDataForPeriods.map(period => {\n        const completePeriod = {};\n        allFieldKeys.forEach(key => {\n          completePeriod[key] = period[key] === undefined ? null : period[key];\n        });\n        return completePeriod;\n      });\n      setIsParsing(false);\n      return {\n        data: finalData,\n        detectedPeriods: detectedNumPeriods\n      };\n    } catch (error) {\n      console.error('Erro ao analisar o arquivo Excel:', error);\n      setParsingError(error);\n      setIsParsing(false);\n      throw error; // Re-throw for the caller to handle\n    }\n  }, [findWorksheet, detectPeriodsInHeader, isConsideredGreyCell]); // Dependencies\n\n  return {\n    parseFile,\n    isParsing,\n    parsingError,\n    setParsingError // Allow clearing error from component\n  };\n}\n_s(useExcelParser, \"g9PFxmMJFKXf2X2VEeM/PZE3NGM=\");","map":{"version":3,"names":["useState","useCallback","GREY_FILLS","HEADER_PATTERNS","fieldDefinitions","useExcelParser","_s","parsingError","setParsingError","isParsing","setIsParsing","findWorksheet","workbook","sheet","worksheets","find","ws","headerRow","getRow","values","Array","isArray","some","cellValue","pattern","toLowerCase","includes","detectPeriodsInHeader","worksheet","headerRowValues","detectedPeriods","forEach","startsWith","length","potentialPeriodHeaders","slice","Math","min","max","isConsideredGreyCell","cell","fill","type","fgColor","argb","fillColor","toUpperCase","grey","endsWith","parseFile","file","ExcelJS","err","Error","wb","Workbook","xlsx","load","arrayBuffer","detectedNumPeriods","extractedDataForPeriods","map","allFieldKeys","Object","keys","foundAnyData","eachRow","row","rowNumber","_row$getCell$value","fieldKeyFromFile","getCell","value","toString","trim","fieldDef","periodIdx","dataCell","firstPeriodOnly","numValue","Number","isNaN","result","undefined","console","warn","finalData","period","completePeriod","key","data","error"],"sources":["/Users/rodrigo/Git Repositories/EnterpriseCashFlow/src/hooks/useExcelParser.js"],"sourcesContent":["// src/hooks/useExcelParser.js\nimport { useState, useCallback } from 'react';\nimport { GREY_FILLS, HEADER_PATTERNS } from '../utils/constants';\nimport { fieldDefinitions } from '../utils/fieldDefinitions'; // Using the same fieldDefinitions\n\nexport function useExcelParser() {\n  const [parsingError, setParsingError] = useState(null);\n  const [isParsing, setIsParsing] = useState(false);\n\n  const findWorksheet = useCallback((workbook) => {\n    const sheet = workbook.worksheets.find(ws => {\n      const headerRow = ws.getRow(1).values; // .values can include empty slots\n      if (!Array.isArray(headerRow)) return false;\n      return headerRow.some(cellValue => \n        typeof cellValue === 'string' && \n        HEADER_PATTERNS.some(pattern => cellValue.toLowerCase().includes(pattern.toLowerCase()))\n      );\n    });\n    return sheet || workbook.worksheets[0]; // Fallback to the first sheet\n  }, []);\n\n  const detectPeriodsInHeader = useCallback((worksheet) => {\n    const headerRowValues = worksheet.getRow(1).values || [];\n    let detectedPeriods = 0;\n    headerRowValues.forEach(cellValue => {\n      if (typeof cellValue === 'string' && cellValue.toLowerCase().startsWith('período ')) {\n        detectedPeriods++;\n      }\n    });\n    // Fallback if \"Período X\" not found, try to infer from number of columns\n    // Assumes structure: Key, Description, P1, P2, ..., Note\n    if (detectedPeriods === 0 && Array.isArray(headerRowValues) && headerRowValues.length >= 3) {\n      // Count columns that are not \"Item (Chave Interna)\", \"Descrição (Português)\", or \"Nota\"\n      const potentialPeriodHeaders = headerRowValues.slice(2, -1); // Exclude first two and last one\n      detectedPeriods = potentialPeriodHeaders.length;\n    }\n\n    if (detectedPeriods === 0) return 2; // Default to 2 if no period columns detected\n    return Math.min(Math.max(detectedPeriods, 1), 6); // Clamp between 1 and 6\n\n  }, []);\n\n  const isConsideredGreyCell = useCallback((cell) => {\n    if (!cell || !cell.fill) return true; // If no fill, treat as inputtable for flexibility\n    if (cell.fill.type === 'pattern' && cell.fill.pattern === 'solid' && cell.fill.fgColor && cell.fill.fgColor.argb) {\n      const fillColor = cell.fill.fgColor.argb.toUpperCase();\n      return GREY_FILLS.some(grey => fillColor === grey || fillColor.endsWith(grey)); // Check with and without FF prefix\n    }\n    return false; // If other fill type or pattern, not considered grey for input\n  }, []);\n\n  const parseFile = useCallback(async (file, ExcelJS) => {\n    setIsParsing(true);\n    setParsingError(null);\n\n    if (!ExcelJS) {\n      const err = new Error(\"Biblioteca ExcelJS não está carregada.\");\n      setParsingError(err);\n      setIsParsing(false);\n      throw err;\n    }\n\n    try {\n      const wb = new ExcelJS.Workbook();\n      await wb.xlsx.load(await file.arrayBuffer());\n\n      const ws = findWorksheet(wb);\n      if (!ws) {\n        throw new Error(\"Nenhuma planilha válida encontrada no arquivo Excel. Verifique se a primeira planilha contém os dados ou se o cabeçalho corresponde aos padrões esperados.\");\n      }\n\n      const detectedNumPeriods = detectPeriodsInHeader(ws);\n      const extractedDataForPeriods = Array(detectedNumPeriods).fill(null).map(() => ({}));\n      const allFieldKeys = Object.keys(fieldDefinitions);\n\n      let foundAnyData = false;\n\n      ws.eachRow((row, rowNumber) => {\n        if (rowNumber === 1) return; // Skip header row\n\n        // Column A for field key (internal English key)\n        const fieldKeyFromFile = row.getCell(1).value?.toString().trim();\n\n        if (!fieldKeyFromFile || !allFieldKeys.includes(fieldKeyFromFile)) {\n            // console.warn(`Linha ${rowNumber}: Chave de campo \"${fieldKeyFromFile}\" não reconhecida ou ausente na coluna A. Pulando linha.`);\n            return;\n        }\n\n        const fieldDef = fieldDefinitions[fieldKeyFromFile];\n\n        for (let periodIdx = 0; periodIdx < detectedNumPeriods; periodIdx++) {\n          const dataCell = row.getCell(3 + periodIdx); // Data starts at column C (ExcelJS is 1-indexed)\n          \n          if (fieldDef.firstPeriodOnly && periodIdx > 0) {\n            extractedDataForPeriods[periodIdx][fieldKeyFromFile] = null;\n            continue;\n          }\n          \n          if (dataCell.value === \"[Não Aplicável]\") {\n            extractedDataForPeriods[periodIdx][fieldKeyFromFile] = null;\n            continue;\n          }\n\n          // Process if it's a grey cell OR if it has a value (for flexibility if user removes formatting)\n          if (isConsideredGreyCell(dataCell) || (dataCell.value !== null && typeof dataCell.value !== 'object')) {\n            const cellValue = dataCell.value;\n            if (cellValue !== null && typeof cellValue !== 'object') { // typeof object can be Date\n              let numValue = Number(cellValue);\n              if (isNaN(numValue) && typeof cellValue === 'object' && cellValue.result !== undefined) { // Formula result\n                numValue = Number(cellValue.result);\n              }\n              \n              if (!isNaN(numValue)) {\n                extractedDataForPeriods[periodIdx][fieldKeyFromFile] = numValue;\n                foundAnyData = true;\n              } else {\n                extractedDataForPeriods[periodIdx][fieldKeyFromFile] = null;\n              }\n            } else {\n              extractedDataForPeriods[periodIdx][fieldKeyFromFile] = null;\n            }\n          } else {\n             extractedDataForPeriods[periodIdx][fieldKeyFromFile] = null; // Not a grey cell / no value\n          }\n        }\n      });\n\n      if (!foundAnyData) {\n        console.warn(\"Nenhum dado numérico encontrado nas células de entrada esperadas do Excel.\");\n        // Optionally throw an error or return empty if this is critical\n      }\n\n      // Ensure all defined fields are present in each period object, even if null\n      const finalData = extractedDataForPeriods.map(period => {\n        const completePeriod = {};\n        allFieldKeys.forEach(key => {\n          completePeriod[key] = period[key] === undefined ? null : period[key];\n        });\n        return completePeriod;\n      });\n\n      setIsParsing(false);\n      return {\n        data: finalData,\n        detectedPeriods: detectedNumPeriods\n      };\n\n    } catch (error) {\n      console.error('Erro ao analisar o arquivo Excel:', error);\n      setParsingError(error);\n      setIsParsing(false);\n      throw error; // Re-throw for the caller to handle\n    }\n\n  }, [findWorksheet, detectPeriodsInHeader, isConsideredGreyCell]); // Dependencies\n\n  return {\n    parseFile,\n    isParsing,\n    parsingError,\n    setParsingError // Allow clearing error from component\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}